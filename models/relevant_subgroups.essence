language ESSENCE' 1.0

given db : mset of record { itemset : set of int, class : int }

given min_freq : int

letting db_minValue be  min([val | entry <- db, val <- entry[itemset]])
letting db_maxValue be max([val | entry <- db, val <- entry[itemset]])
letting db_maxEntrySize be max([ |entry[itemset]| | entry <- db ])
letting db_row_size be |db|
$ letting db_min_class_value be min([entry[class] | entry <- db])
$ letting db_max_class_value be max([entry[class] | entry <- db])

given utility_values : matrix indexed by [int(db_minValue..db_maxValue)] of int
given cost_values : matrix indexed by [int(db_minValue..db_maxValue)] of int

given min_utility : int
given max_cost : int

$ letting class_domain be domain int(db_min_class_value..db_max_class_value)
letting class_domain be domain int(0..1)

letting support_domain be domain int(1..db_row_size)


$keep wanted class for now in this model.
find freq_items : record { 
                        itemset : set (minSize 1, maxSize db_maxEntrySize) of int(db_minValue..db_maxValue), 
                        wanted_class : class_domain,
                        support_func : function (total) class_domain --> support_domain
                    } 

$focus on positive directly, but keep wanted as 1
such that
    freq_items[wanted_class] = 1

$ frequency
such that
    forAll (f_class, f_support) in freq_items[support_func] .
        (sum entry in db . toInt(freq_items[itemset] subsetEq entry[itemset] /\ entry[class] = f_class)) = f_support

$ supp X+ > min_freq
such that
    freq_items[support_func](freq_items[wanted_class]) > min_freq



$ utilities

such that
    (sum item in freq_items[itemset] . utility_values[item]) >= min_utility

such that
    (sum item in freq_items[itemset] . cost_values[item]) <= max_cost


$ option 1: not sure?
$ there isnt any superset Y that Y+ > X+ and X- > Y- and X = Y can be expressed as
$ Y superset X implies that X+ > Y+ or Y- > X- or Y!=X 
$ - i.e. in english if we are finding subsets of stuff we have found so far, some support must be different in +, - or total.

$ dominance_relation (freq_items[itemset] subsetEq fromSolution(freq_items[itemset])) -> 
$ (freq_items[support_func](1) > fromSolution(freq_items[support_func](1)) 
$ \/ (freq_items[support_func](0) < fromSolution(freq_items[support_func](0)))
$ \/ (freq_items[support_func](1) + freq_items[support_func](0) != fromSolution(freq_items[support_func](1)) + fromSolution(freq_items[support_func](0))))

$ option 2: closer to the orig spec
$ there isnt any other itemset with more + supp, less - supp and if same total supp bigger one ->
$ X+ > Y+ or Y- > X- or Y superset X -> Y!=X 
dominance_relation freq_items[support_func](1) > fromSolution(freq_items[support_func](1)) 
\/ freq_items[support_func](0) < fromSolution(freq_items[support_func](0)) 
\/ (freq_items[itemset] subsetEq fromSolution(freq_items[itemset]) -> (freq_items[support_func](1) + freq_items[support_func](0) != fromSolution(freq_items[support_func](1)) + fromSolution(freq_items[support_func](0))))

incomparability_function descending |freq_items[itemset]|

    
