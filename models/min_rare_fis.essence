language ESSENCE' 1.0

given db : mset of set of int

given min_freq : int

letting db_minValue be  min([val | entry <- db, val <- entry])
letting db_maxValue be max([val | entry <- db, val <- entry])
letting db_maxEntrySize be max([ |entry| | entry <- db ])
letting db_row_size be |db|

given utility_values : matrix indexed by [int(db_minValue..db_maxValue)] of int
given cost_values : matrix indexed by [int(db_minValue..db_maxValue)] of int

given min_utility : int
given max_cost : int

find infreq_items : record { itemset : set (maxSize db_maxEntrySize) of int(db_minValue..db_maxValue), support : int(1..db_row_size) }

$ frequency

such that
    (sum entry in db . toInt(infreq_items[itemset] subsetEq entry)) = infreq_items[support]

such that
    infreq_items[support] < min_freq

$ utilities

such that
    (sum item in infreq_items[itemset] . utility_values[item]) >= min_utility

such that
    (sum item in infreq_items[itemset] . cost_values[item]) <= max_cost

$ generator dominance on small non-freq itemsets dominates biggers ones.

dominance_relation !(fromSolution(infreq_items[itemset]) subsetEq infreq_items[itemset])

incomparability_function ascending |infreq_items[itemset]|

    
